
선택정렬
 - 처리 되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복    시간복잡도 O(N^2)
 
삽입정렬
  - 처리 되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입                                       시간복잡도 O(N^2)
  - 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적이다.                        최고 경우 O(N)
  

퀵 정렬

  - 기준 데이터를 설정하고(피봇) 그 기준보다 큰 데이터와 작은 데어틔 위치를 바꾸는 방법            평균경우 분할이 O(NlogN) 기대
  - 일반적인 상황에서 가장 많이 사용되고                                                        최악의 경우  O(N^2)    
  - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리 근간이 되는 알고리즘
  - 가장 기본적인 퀵정렬은 첫 번째 데이터를 피봇으로 설정한다.
  
  
  퀵소트 파이썬
  
  array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
  
  def quick_sort(array):
    if len(array) <= 1:
      return array
      
    pivot = array[0]
    tail = array[1:]
    
    left_side = [x for x in tail if x <= pivot]
    right_side = [x for x in tail if x > pivot]
    
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)
    
 계수 정렬
  - 특정한 조건이 부합할 때만 사용할 수 있고 매우 빠르게 동작 
    (데이터의 크기 범위가 제한되어 정수 형태로 포현할 수 있을 때 사용 가능
  - 데이터의 개수가 N, 데이터 중 최대값이 K일 때 최악의 경우에도 O(N+K)보장
    데이터가 0 과 100000 두개 존재하는 경우 100001 담는 배열  비효과적
    성적의 경우 100점 맞은 학생이 여러 명 일 수 있기 때문에 계수 정렬 효과적
    
    
    
    
    
    
    
     
                    평균 시간 복잡도           공간복잡도
    선택                N^2                       N
    삽입                N^2                       N
    퀵                 NlogN                      N
    계수                N+k                      N+k
    
    
    
    
   여러 키 값으로 정렬
   
   sorted(자료형(list), key = lambda x : (x['age'], k['name'])) 
   같은 age에 대해서 name으로 정렬


 아이템 첫 번째 인자를 기준으로 오름차순으로 먼저 정렬하고,
 그리고 그 안에서 다음 두 번째 인자를 기준으로 내림차순으로 정렬하게 하려면, 다음과 같이 할 수 있다.
e = [(1, 3), (0, 3), (1, 4), (1, 5), (0, 1), (2, 4)]
f = sorted(e, key = lambda x : (x[0], -x[1]))
# f = [(0, 3), (0, 1), (1, 5), (1, 4), (1, 3), (2, 4)]
